{"version":3,"file":"mask.js","names":["computed","shallowRef","isObject","propsFactory","makeMaskProps","mask","String","Object","returnMaskedValue","Boolean","defaultDelimiters","presets","date","phone","social","time","isMaskDelimiter","char","test","defaultTokens","pattern","A","convert","v","toUpperCase","a","toLowerCase","N","n","X","useMask","props","inputRef","tokens","selection","lazySelection","isMask","value","maskValidates","item","maskText","text","trimmedText","trim","replace","length","textIndex","maskIndex","newText","mchar","tchar","unmaskText","setCaretPosition","newSelection","setSelectionRange","resetSelections","selectionEnd","index","updateRange","newValue"],"sources":["../../src/composables/mask.ts"],"sourcesContent":["// Utilities\nimport { computed, shallowRef } from 'vue'\nimport { isObject, propsFactory } from '@/util'\n\n// Types\nimport type { PropType, Ref } from 'vue'\n\nexport interface MaskProps {\n  mask: string | MaskOptions | undefined\n  returnMaskedValue?: boolean\n}\n\nexport interface MaskOptions {\n  mask: string\n  tokens: Record<string, MaskItem>\n}\n\nexport const makeMaskProps = propsFactory({\n  mask: [String, Object] as PropType<string | MaskOptions>,\n  returnMaskedValue: Boolean,\n}, 'mask')\n\nexport type MaskItem = {\n  convert?: (char: string) => string\n} & ({\n  pattern?: never\n  test: (char: string) => boolean\n} | {\n  pattern: RegExp\n  test?: never\n})\n\nexport const defaultDelimiters = /[-!$%^&*()_+|~=`{}[\\]:\";'<>?,./\\\\ ]/\n\nconst presets: Record<string, string> = {\n  'credit-card': '#### - #### - #### - ####',\n  date: '##/##/####',\n  'date-time': '##/##/#### ##:##',\n  'iso-date': '####-##-##',\n  'iso-date-time': '####-##-## ##:##',\n  phone: '(###) ### - ####',\n  social: '###-##-####',\n  time: '##:##',\n  'time-with-seconds': '##:##:##',\n}\n\nexport function isMaskDelimiter (char: string): boolean {\n  return char ? defaultDelimiters.test(char) : false\n}\n\nconst defaultTokens: Record<string, MaskItem> = {\n  '#': {\n    pattern: /[0-9]/,\n  },\n  A: {\n    pattern: /[A-Z]/i,\n    convert: v => v.toUpperCase(),\n  },\n  a: {\n    pattern: /[a-z]/i,\n    convert: v => v.toLowerCase(),\n  },\n  N: {\n    pattern: /[0-9A-Z]/i,\n    convert: v => v.toUpperCase(),\n  },\n  n: {\n    pattern: /[0-9a-z]/i,\n    convert: v => v.toLowerCase(),\n  },\n  X: {\n    pattern: defaultDelimiters,\n  },\n}\n\nexport function useMask (props: MaskProps, inputRef: Ref<HTMLInputElement | undefined>) {\n  const mask = computed(() => {\n    if (typeof props.mask === 'string') {\n      if (props.mask in presets) return presets[props.mask]\n      return props.mask\n    }\n    return props.mask?.mask ?? ''\n  })\n  const tokens = computed(() => {\n    return {\n      ...defaultTokens,\n      ...(isObject(props.mask) ? props.mask.tokens : null),\n    }\n  })\n  const selection = shallowRef(0)\n  const lazySelection = shallowRef(0)\n\n  function isMask (char: string): boolean {\n    return char in tokens.value\n  }\n\n  function maskValidates (mask: string, char: string): boolean {\n    if (char == null || !isMask(mask)) return false\n    const item = tokens.value[mask]\n    if (item.pattern) return item.pattern.test(char)\n    return item.test(char)\n  }\n\n  function convert (mask: string, char: string): string {\n    const item = tokens.value[mask]\n    return item.convert ? item.convert(char) : char\n  }\n\n  function maskText (text: string | null | undefined): string {\n    const trimmedText = text?.trim().replace(/\\s+/g, ' ')\n\n    if (trimmedText == null) return ''\n\n    if (!mask.value.length || !trimmedText.length) return trimmedText\n\n    let textIndex = 0\n    let maskIndex = 0\n    let newText = ''\n\n    while (maskIndex < mask.value.length) {\n      const mchar = mask.value[maskIndex]\n      const tchar = trimmedText[textIndex]\n\n      // Escaped character in mask, the next mask character is inserted\n      if (mchar === '\\\\') {\n        newText += mask.value[maskIndex + 1]\n        maskIndex += 2\n        continue\n      }\n\n      if (!isMask(mchar)) {\n        newText += mchar\n        if (tchar === mchar) {\n          textIndex++\n        }\n      } else if (maskValidates(mchar, tchar)) {\n        newText += convert(mchar, tchar)\n        textIndex++\n      } else {\n        break\n      }\n\n      maskIndex++\n    }\n    return newText\n  }\n\n  function unmaskText (text: string | null): string | null {\n    if (text == null) return null\n\n    if (!mask.value.length || !text.length) return text\n\n    let textIndex = 0\n    let maskIndex = 0\n    let newText = ''\n\n    while (true) {\n      const mchar = mask.value[maskIndex]\n      const tchar = text[textIndex]\n\n      if (tchar == null) break\n\n      if (mchar == null) {\n        newText += tchar\n        textIndex++\n        continue\n      }\n\n      // Escaped character in mask, skip the next input character\n      if (mchar === '\\\\') {\n        if (tchar === mask.value[maskIndex + 1]) {\n          textIndex++\n        }\n        maskIndex += 2\n        continue\n      }\n\n      if (maskValidates(mchar, tchar)) {\n        // masked char\n        newText += tchar\n        textIndex++\n        maskIndex++\n        continue\n      } else if (mchar !== tchar) {\n        // input doesn't match mask, skip forward until it does\n        while (true) {\n          const mchar = mask.value[maskIndex++]\n          if (mchar == null || maskValidates(mchar, tchar)) break\n        }\n        continue\n      }\n\n      textIndex++\n      maskIndex++\n    }\n    return newText\n  }\n\n  function setCaretPosition (newSelection: number) {\n    selection.value = newSelection\n    inputRef.value && inputRef.value.setSelectionRange(selection.value, selection.value)\n  }\n\n  function resetSelections () {\n    if (!inputRef.value?.selectionEnd) return\n\n    selection.value = inputRef.value.selectionEnd\n    lazySelection.value = 0\n\n    for (let index = 0; index < selection.value; index++) {\n      isMaskDelimiter(inputRef.value.value[index]) || lazySelection.value++\n    }\n  }\n\n  function updateRange () {\n    if (!inputRef.value) return\n    resetSelections()\n\n    let selection = 0\n    const newValue = inputRef.value.value\n\n    if (newValue) {\n      for (let index = 0; index < newValue.length; index++) {\n        if (lazySelection.value <= 0) break\n        isMaskDelimiter(newValue[index]) || lazySelection.value--\n        selection++\n      }\n    }\n    setCaretPosition(selection)\n  }\n\n  return {\n    updateRange,\n    maskText,\n    unmaskText,\n  }\n}\n"],"mappings":"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","ignoreList":[]}